package bridge.scene.v4;

/**
 * Description: 客户端类<br/>
 *
 *       手机品牌 ◇----------手机软件
 *          △                △
 *          |                |
 *     ----------        ------------
 *     |         |       |           |
 *  手机品牌M  手机品牌N  通讯录       游戏
 *
 * 对象的继承关系在编译时就定义好了，所以无法在运行时改变从父类继承的实现。
 * 子类的实现与父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类的变化。
 * 当需要重复使用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换
 * 这种依赖关系限制了灵活性并最终限制了复用性，这时从可以考虑使用组合的关系来实现类对象的复用性
 *
 * 合成/聚合复用原则：尽量使用合成/聚合原则，尽量不要使用类的继承
 *
 * 聚合表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分
 * 合成则是一种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一致
 *
 * 合成/聚合复用原则的好处：优先使用对象的合成/聚合将有助于保持每个类被封装，并集中在单个任务上，这样类和类继承层次会保持较小规模
 * 并且不太可能增长为不可控制的庞然大物。
 *
 * 在这个场景中：无论是从手机品牌的角度还是从软件角度进行分类，当新增手机品牌或手机新增软件功能时，代码的改动量都是巨大的
 *            所以将手机品牌抽象出来，具体的手机品牌实现手机品牌抽象类
 *                 手机软件功能抽象出来，具体的手机软件开发实现手机软件功能
 *                 而手机软件功能与手机品牌之间则是组合关系，手机软件要运行需要先在不同手机品牌上安装对象的手机软件，才可以使用软件
 *            这样分离后，后续新增手机品牌类S，只需新增一个手机品牌的实现类即可
 *                         手机新增软件MP3，也只需新增软件功能MP3的实现类即可
 * @author wangzhao
 * @version 1.0
 * @email 13132398914@163.com
 * @date 2024/8/8 17:33
 */
public class Client {

    public static void main(String[] args) {
        HandsetBrand hb;
        //手机品牌N
        hb = new HandsetBrandN();

        //手机品牌N安装游戏
        hb.setSoft(new HandsetGame());
        hb.run();
        //手机品牌N安装通讯录
        hb.setSoft(new HandsetContact());
        hb.run();

        //手机品牌M
        hb = new HandsetBrandM();
        //手机品牌M安装游戏
        hb.setSoft(new HandsetGame());
        hb.run();
        //手机品牌M安装通讯录
        hb.setSoft(new HandsetContact());
        hb.run();

        //手机品牌M安装MP3播放器
        hb.setSoft(new HandsetMp3());
        hb.run();
    }

}
